<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>MCWorld Experiments Editor — Education Edition</title>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismarine-nbt@1.11.0/dist/prismarine-nbt-with-bytebuffer.min.js"></script>

<style>
  body{font-family:system-ui;background:#f4f4f8;margin:0;padding:40px;color:#111}
  .card{max-width:900px;margin:0 auto;background:#fff;padding:24px;border-radius:14px;box-shadow:0 10px 40px rgba(0,0,0,.08)}
  h1{margin-top:0;font-size:1.9em;color:#0b74ff}
  .drop{border:2px dashed #ccc;border-radius:12px;padding:26px;text-align:center;font-size:1.1em;background:#fafafa;cursor:pointer}
  .exps{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:10px;margin-top:16px}
  button{padding:12px 20px;border:none;border-radius:10px;background:#0b74ff;color:#fff;font-size:1em;cursor:pointer;margin-top:12px}
  pre{background:#f7f7f7;padding:14px;border-radius:8px;max-height:260px;overflow:auto;font-size:.9em}
</style>
</head>
<body>

<div class="card">
  <h1>.mcworld Experiments Editor — Education Edition</h1>
  <p>Enable **full experimental gameplay** inside any <code>.mcworld</code> file. 100% in your browser.</p>

  <div id="drop" class="drop">
    Drop a <code>.mcworld</code> here<br><br>
    <input id="fileInput" type="file" accept=".mcworld,.zip" />
  </div>

  <div id="status" style="margin-top:12px;color:#555"><small>Waiting for file...</small></div>

  <div id="controls" style="display:none;margin-top:18px">
    <h3>Select Experiments</h3>
    <div id="expList" class="exps"></div>
    <button id="processBtn">Download Modified .mcworld</button>
  </div>

  <hr style="margin:24px 0">
  <h3>Debug Output</h3>
  <pre id="out"></pre>
</div>

<script>
const JSZip = window.JSZip;
const pako = window.pako;
const nbt = window.nbt;

const out = document.getElementById("out");
const statusEl = document.getElementById("status");

function log(...msg){
  out.textContent += msg.join(" ") + "\n";
  out.scrollTop = out.scrollHeight;
}

const EXPERIMENTS = [
  "experimental_gameplay",
  "holiday_creator_features",
  "beta_api",
  "upcoming_creator_features",
  "caves_and_cliffs",
  "compressed_chunks",
  "actor_system",
  "restructured_world_generation",
  "fluid_tick_updates",
  "terrain_generation_v2"
];

function buildUI(){
  const box = document.getElementById("expList");
  box.innerHTML = "";
  for(const e of EXPERIMENTS){
    const row = document.createElement("label");
    row.innerHTML = `<input type="checkbox" class="ex" value="${e}"> ${e}`;
    box.appendChild(row);
  }
}
buildUI();

// drag/drop
const drop = document.getElementById("drop");
["dragenter","dragover"].forEach(ev =>
  drop.addEventListener(ev, e=>{
    e.preventDefault();
    drop.style.borderColor="#0b74ff";
  })
);
["dragleave","drop"].forEach(ev =>
  drop.addEventListener(ev, e=>{
    e.preventDefault();
    drop.style.borderColor="#ccc";
  })
);
drop.addEventListener("drop", e=>{
  const file = e.dataTransfer.files[0];
  if(file) loadWorld(file);
});

document.getElementById("fileInput").addEventListener("change", e=>{
  const file = e.target.files[0];
  if(file) loadWorld(file);
});

let zip = null;
let levelPath = null;
let parsedNBT = null;
let baseName = "world";

async function loadWorld(file){
  out.textContent = "";
  statusEl.innerHTML = `<small>Loading ${file.name}...</small>`;
  baseName = file.name.replace(/\.(mcworld|zip)$/i,"");

  try{
    zip = await JSZip.loadAsync(file);
  } catch(e){
    log("Failed to read zip", e);
    statusEl.innerHTML = "<small style='color:red'>Invalid .mcworld file</small>";
    return;
  }

  statusEl.innerHTML = "<small>Loaded. Searching for level.dat...</small>";

  // find level.dat
  zip.forEach((p,entry)=>{
    if(p.toLowerCase().endsWith("level.dat")) levelPath = p;
  });

  if(!levelPath){
    statusEl.innerHTML = "<small style='color:red'>level.dat not found</small>";
    return;
  }

  log("Found:", levelPath);

  const raw = await zip.file(levelPath).async("uint8array");
  let data = raw;

  // Try gunzip
  let uncompressed = null;
  try{
    uncompressed = pako.ungzip(raw);
    log("Gzip detected, decompressed:", uncompressed.length);
  } catch(err){
    log("Not gzipped; using raw bytes");
    uncompressed = raw;
  }

  // IMPORTANT: EDU worlds use LITTLE ENDIAN NBT → parseUncompressed()
  try{
    parsedNBT = await new Promise((resolve,reject)=>{
      nbt.parseUncompressed(uncompressed, (err, result)=>{
        if(err) reject(err); else resolve(result);
      });
    });
  } catch(e){
    log("NBT error:", e);
    statusEl.innerHTML = "<small style='color:red'>Failed to parse NBT</small>";
    return;
  }

  statusEl.innerHTML = "<small>World loaded. Experiments ready.</small>";
  document.getElementById("controls").style.display = "block";

  // Read existing experiments
  try{
    const root = parsedNBT.value;
    let expTag = null;

    if(root.Data?.value?.Experiments?.value){
      expTag = root.Data.value.Experiments.value;
    }
    if(root.Experiments?.value){
      expTag = root.Experiments.value;
    }

    if(expTag){
      const active = new Set(
        Object.keys(expTag).filter(k=>expTag[k].value === 1)
      );

      document.querySelectorAll(".ex").forEach(cb=>{
        cb.checked = active.has(cb.value);
      });
    }
  } catch(e){
    log("Experiment read error:", e);
  }
}

document.getElementById("processBtn").addEventListener("click", async ()=>{
  if(!parsedNBT) return alert("Load a world first!");

  const chosen = [...document.querySelectorAll(".ex:checked")].map(cb=>cb.value);

  const root = parsedNBT.value;
  if(!root.Data) root.Data = { type:"compound", value:{} };
  if(!root.Data.value) root.Data.value = {};

  const expMap = {};
  for(const e of chosen){
    expMap[e] = { type:"byte", value:1 };
  }

  root.Data.value.Experiments = { type:"compound", value:expMap };
  root.Experiments = { type:"compound", value:expMap };

  // Write NBT (LITTLE-ENDIAN)
  let outBytes;
  try{
    outBytes = nbt.writeUncompressed(parsedNBT);
  } catch(e){
    log("NBT write error:", e);
    return;
  }

  // Re-gzip for safety (Minecraft loads both)
  let gz = pako.gzip(outBytes);

  zip.file(levelPath, gz);

  const blob = await zip.generateAsync({ type:"blob" });

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = baseName + "_experiments.mcworld";
  a.click();

  statusEl.innerHTML = "<small>Download ready!</small>";
});
</script>

</body>
</html>
