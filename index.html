<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>MCWorld Experiments Editor — Clone</title>
  <!-- JS libraries -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <!-- prismarine-nbt UMD (browser bundle). If this 404s, we'll fallback to an inline error message. -->
  <script src="https://unpkg.com/prismarine-nbt@1.11.0/dist/index.umd.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:24px}
    .card{max-width:820px;padding:18px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
    .row{display:flex;gap:12px;align-items:center}
    .drop{border:2px dashed #d0d0d0;padding:18px;border-radius:8px;text-align:center}
    .exps{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:8px;margin-top:12px}
    button{padding:10px 14px;border-radius:8px;border:none;background:#0066ff;color:white}
    small{color:#666}
  </style>
</head>
<body>
  <div class="card">
    <h1>MCWorld Experiments Editor (clone)</h1>
    <p>Upload a <code>.mcworld</code> file, toggle experiments, and download a modified world. Make a backup of your world first!</p>

    <div class="row">
      <div style="flex:1">
        <div id="drop" class="drop">Drop .mcworld here or <input id="fileInput" type="file" accept=".mcworld,.zip" style="display:inline-block"></div>
        <div id="status" style="margin-top:10px"><small>Waiting for file...</small></div>
      </div>
    </div>

    <div id="controls" style="display:none;margin-top:14px">
      <h3>Choose experiments to enable</h3>
      <div class="exps" id="expList">
        <!-- common experiment ids; you can add more -->
      </div>
      <div style="margin-top:14px">
        <button id="processBtn">Build & Download .mcworld</button>
      </div>
    </div>

    <hr style="margin-top:18px">
    <p style="font-size:0.9em;color:#444">If parsing fails, you'll see an error below with hints — this clone aims to behave like jaylydev's tool. If something fails, save the console output and I'll help fix it.</p>
    <pre id="output" style="white-space:pre-wrap;background:#f8f8f8;padding:10px;border-radius:8px;max-height:220px;overflow:auto"></pre>
  </div>

<script>
(async ()=>{
  const JSZip = window.JSZip;
  const pako = window.pako;
  const prismarineNbt = window.prismarineNbt || window.prismarineNbtExport || window['prismarine-nbt'] || window['nbt'];

  function log(...args){
    console.log(...args);
    const out = document.getElementById('output');
    out.textContent += args.map(a=>typeof a==='object'?JSON.stringify(a,null,2):String(a)).join(' ') + '
';
    out.scrollTop = out.scrollHeight;
  }

  const status = document.getElementById('status');
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const controls = document.getElementById('controls');
  const expList = document.getElementById('expList');
  const processBtn = document.getElementById('processBtn');

  const commonExps = [
    'experimental_gameplay',
    'holiday_creator_features',
    'beta_api',
    'upcoming_creator_features',
    'caves_and_cliffs',
    'tweaks',
    'new_biomes',
    'compressed_chunks'
  ];

  function buildExpUI(){
    expList.innerHTML = '';
    commonExps.forEach(id=>{
      const lbl = document.createElement('label');
      lbl.style.display='block';
      lbl.innerHTML = `<input type="checkbox" class="exp" value="${id}"> ${id}`;
      expList.appendChild(lbl);
    });
  }
  buildExpUI();

  // drag & drop
  ['dragenter','dragover'].forEach(ev=>{
    drop.addEventListener(ev,e=>{e.preventDefault();drop.style.borderColor='#888'});
  });
  ['dragleave','drop'].forEach(ev=>{
    drop.addEventListener(ev,e=>{e.preventDefault();drop.style.borderColor='#d0d0d0'});
  });
  drop.addEventListener('drop',e=>{e.preventDefault();
    const f = e.dataTransfer.files[0]; if(f) handleFile(f);
  });
  fileInput.addEventListener('change',e=>{const f=e.target.files[0]; if(f) handleFile(f)});

  let currentZip = null;
  let currentFilename = '';
  async function handleFile(file){
    document.getElementById('output').textContent='';
    status.innerHTML = `<small>Loading ${file.name}...</small>`;
    currentFilename = file.name.replace(/\.mcworld$|\.zip$/i,'') || 'edited_world';
    try{
      const zip = await JSZip.loadAsync(file);
      currentZip = zip;
      status.innerHTML = `<small>Archive loaded — looking for <code>level.dat</code>...</small>`;

      // locate level.dat (case-insensitive)
      let levelFile = null;
      zip.forEach((relPath, zipEntry)=>{
        if(relPath.toLowerCase().endsWith('level.dat')) levelFile = zipEntry;
      });
      if(!levelFile){
        status.innerHTML = `<small style="color:crimson">No level.dat found in archive.</small>`;
        log('No level.dat found. Files in archive:');
        zip.forEach((p,entry)=>log(p));
        return;
      }

      status.innerHTML = `<small>Found level.dat — parsing...</small>`;
      const raw = await levelFile.async('arraybuffer');
      let buf = new Uint8Array(raw);

      // level.dat in Bedrock is typically GZIP-compressed NBT
      let nbtBuffer = null;
      try{
        nbtBuffer = pako.ungzip(buf);
        log('Ungzipped level.dat (gzip) — length', nbtBuffer.length);
      }catch(e){
        // maybe not gzipped; try using raw buffer
        nbtBuffer = buf;
        log('level.dat not gzip or ungzip failed, using raw bytes');
      }

      // parse NBT using prismarine-nbt
      if(!prismarineNbt || !prismarineNbt.parse){
        status.innerHTML = `<small style="color:crimson">NBT library not loaded (prismarine-nbt). Check console.</small>`;
        log('prismarine-nbt not available on window:', Object.keys(window).filter(k=>k.toLowerCase().includes('nbt')).slice(0,20));
        return;
      }

      // prismarine-nbt.parse takes (buffer, callback) in UMD; it returns a promise in newer versions
      let parsed = null;
      try{
        // try promise style
        parsed = await new Promise((resolve,reject)=>{
          prismarineNbt.parse(Buffer.from(nbtBuffer), (err,data)=>{ if(err) reject(err); else resolve(data); });
        });
      }catch(err){
        log('parse failed:', err);
        status.innerHTML = `<small style="color:crimson">NBT parse failed — see output for details.</small>`;
        return;
      }

      log('NBT parsed — root keys:', Object.keys(parsed.value||{}));
      status.innerHTML = `<small>NBT parsed — ready. Choose experiments and press Build.</small>`;
      controls.style.display = 'block';

      // store parsed for process step
      window._mc_parsed = parsed;
      window._mc_levelPath = levelFile.name;

      // pre-check currently enabled experiments (if present)
      try{
        const root = parsed.value;
        // Bedrock often stores experiments at root.Experiments or root.Data.Experiments
        let experimentsTag = null;
        if(root.Experiments) experimentsTag = root.Experiments;
        else if(root.Data && root.Data.value && root.Data.value.Experiments) experimentsTag = root.Data.value.Experiments;
        else if(root.Data && root.Data.Experiments) experimentsTag = root.Data.Experiments;

        const checked = new Set();
        if(experimentsTag && experimentsTag.value){
          // experimentsTag.value expected to be an object mapping ids to {value:true}
          for(const k in experimentsTag.value){
            if(experimentsTag.value[k] && (experimentsTag.value[k].value === true || experimentsTag.value[k].value === 1)) checked.add(k);
          }
        }
        // check checkboxes
        document.querySelectorAll('.exp').forEach(cb=>{ cb.checked = checked.has(cb.value); });
      }catch(e){ log('precheck experiments failed:', e); }

    }catch(e){
      status.innerHTML = `<small style="color:crimson">Failed to read zip: ${e.message}</small>`;
      log('Error loading zip:', e);
    }
  }

  processBtn.addEventListener('click', async ()=>{
    if(!window._mc_parsed || !currentZip) return alert('No parsed world present. Load a .mcworld first.');
    log('Starting build...');
    const parsed = window._mc_parsed;
    const levelPath = window._mc_levelPath;

    // Build experiments object from checked boxes
    const chosen = Array.from(document.querySelectorAll('.exp:checked')).map(i=>i.value);
    log('Chosen experiments:', chosen);

    // find where to put Experiments tag — try root.Experiments, root.Data.Experiments
    const root = parsed.value;
    if(!root) return alert('Unexpected parsed NBT format');

    // ensure Data compound exists
    if(!root.Data){ root.Data = { type:'compound', value: {} }; }
    const dataCompound = root.Data.value || root.Data;

    // Create experiments structure as expected: compound where each key = {type:'byte',value:1} or {type:'byte',value:1}
    const experimentsObj = {};
    chosen.forEach(id=>{ experimentsObj[id] = { type:'byte', value: 1 }; });

    // set experiments under Data.Experiments (common for Bedrock)
    dataCompound.Experiments = { type: 'compound', value: experimentsObj };

    // Also set root.Experiments in case some worlds expect it
    root.Experiments = { type: 'compound', value: experimentsObj };

    // Now write NBT buffer back
    try{
      // prismarine-nbt.writeUncompressed (or write) — try available functions
      let newNbtBuffer = null;
      if(prismarineNbt.writeUncompressed){
        newNbtBuffer = prismarineNbt.writeUncompressed(parsed);
      }else if(prismarineNbt.write){
        newNbtBuffer = prismarineNbt.write(parsed);
      }else if(prismarineNbt.compiled && prismarineNbt.compiled.writeUncompressed){
        newNbtBuffer = prismarineNbt.compiled.writeUncompressed(parsed);
      }else{
        throw new Error('prismarine-nbt write function not found');
      }

      // newNbtBuffer may be a Node Buffer or Uint8Array
      let outBytes = newNbtBuffer;
      if(typeof outBytes.copy === 'function' && outBytes instanceof Uint8Array === false){
        // convert Node Buffer to Uint8Array
        outBytes = new Uint8Array(outBytes);
      }

      // gzip the output (level.dat is usually gzipped)
      const gzipped = pako.gzip(outBytes);

      // replace level.dat inside zip
      currentZip.file(levelPath, gzipped, {binary:true});

      // generate new zip
      status.innerHTML = `<small>Building .mcworld...</small>`;
      const newBlob = await currentZip.generateAsync({type:'blob'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(newBlob);
      a.download = currentFilename + '_edited.mcworld';
      a.click();
      status.innerHTML = `<small>Done — downloaded ${a.download}</small>`;
      log('Build complete — file downloaded');

    }catch(e){
      log('Error while writing NBT / building mcworld:', e);
      status.innerHTML = `<small style="color:crimson">Build failed — see console/output.</small>`;
    }

  });

})();
</script>
</body>
</html>
