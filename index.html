<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>MCWorld Experiments Editor EDU</title>
  <meta name="description" content="Edit Bedrock .mcworld level.dat experiments entirely in-browser.">

  <!-- Libraries: JSZip (zip), pako (gzip), prismarine-nbt (NBT read/write UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismarine-nbt@1.11.0/dist/index.umd.js"></script>

  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:28px;background:#fafafa;color:#111}
    .card{max-width:880px;margin:0 auto;background:white;padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.06)}
    .drop{border:2px dashed #e1e1e1;padding:22px;border-radius:10px;text-align:center}
    .exps{display:grid;grid-template-columns:repeat(auto-fit,minmax(210px,1fr));gap:8px;margin-top:12px}
    label{display:block}
    button{padding:10px 14px;border-radius:8px;border:none;background:#0b74ff;color:white;cursor:pointer}
    pre{background:#f7f7f7;padding:10px;border-radius:8px;max-height:220px;overflow:auto}
    small{color:#666}
  </style>
</head>
<body>
  <div class="card">
    <h1>MCWorld Experiments Editor — Bedrock-safe</h1>
    <p>Edit the <code>level.dat</code> experiments tag inside a <code>.mcworld</code> entirely in your browser. Always keep a backup.</p>

    <div id="drop" class="drop">Drop a <code>.mcworld</code> or <code>.zip</code> here<br><br>
      <input id="fileInput" type="file" accept=".mcworld,.zip" style="display:inline-block"></div>
    <div id="status" style="margin-top:12px"><small>Waiting for file...</small></div>

    <div id="controls" style="display:none;margin-top:14px">
      <h3>Enable experiments</h3>
      <div class="exps" id="expList"></div>
      <div style="margin-top:12px"><button id="processBtn">Build &amp; Download .mcworld</button></div>
    </div>

    <hr style="margin-top:18px">
    <p style="font-size:0.9em;color:#444">Output / debug:</p>
    <pre id="output"></pre>
  </div>

<script>
(async()=>{
  function toUint8Array(buf){
    if(buf instanceof Uint8Array) return buf;
    if(typeof Buffer !== 'undefined' && Buffer.isBuffer(buf)) return new Uint8Array(buf);
    return new Uint8Array(buf);
  }

  const JSZip = window.JSZip;
  const pako = window.pako;
  const nbtLib = window.NBT || window.prismarineNbt;

  const statusEl = document.getElementById('status');
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('fileInput');
  const controls = document.getElementById('controls');
  const expList = document.getElementById('expList');
  const processBtn = document.getElementById('processBtn');
  const out = document.getElementById('output');

  function log(...a){
    console.log(...a);
    out.textContent += a.map(x => typeof x==='object' ? JSON.stringify(x,null,2) : String(x)).join(' ') + '\n';
    out.scrollTop = out.scrollHeight;
  }

  if(!nbtLib){
    statusEl.innerHTML = `<small style="color:crimson">NBT library unavailable</small>`;
    log('prismarine-nbt missing on window');
    return;
  }

  const commonExps = [
    'experimental_gameplay','holiday_creator_features','beta_api','upcoming_creator_features',
    'caves_and_cliffs','compressed_chunks','actor_system','restructured_world_generation',
    'fluid_tick_updates','terrain_generation_v2'
  ];

  function buildExpUI(){
    expList.innerHTML = '';
    commonExps.forEach(id=>{
      const l = document.createElement('label');
      l.innerHTML = `<input type="checkbox" class="exp" value="${id}"> ${id}`;
      expList.appendChild(l);
    });
  }
  buildExpUI();

  ['dragenter','dragover'].forEach(e=>drop.addEventListener(e, ev=>{ev.preventDefault();drop.style.borderColor='#999'}));
  ['dragleave','drop'].forEach(e=>drop.addEventListener(e, ev=>{ev.preventDefault();drop.style.borderColor='#e1e1e1'}));
  drop.addEventListener('drop', ev=>{ev.preventDefault(); const f=ev.dataTransfer.files[0]; if(f) handleFile(f);});
  fileInput.addEventListener('change', ev=>{ const f=ev.target.files[0]; if(f) handleFile(f); });

  let currentZip = null;
  let currentLevelPath = null;
  let currentParsed = null;
  let currentFilename = 'edited_world';

  async function handleFile(file){
    out.textContent='';
    statusEl.innerHTML = `<small>Loading ${file.name}...</small>`;
    currentFilename = file.name.replace(/\.mcworld$|\.zip$/i,'') || 'edited_world';
    try{
      const zip = await JSZip.loadAsync(file);
      currentZip = zip;
      statusEl.innerHTML = `<small>Archive loaded — searching for level.dat...</small>`;

      let levelEntry = null;
      zip.forEach((path, entry)=>{ if(path.toLowerCase().endsWith('level.dat')) levelEntry = entry; });
      if(!levelEntry){ statusEl.innerHTML = `<small style="color:crimson">level.dat not found</small>`; log('Archive contents:'); zip.forEach((p)=>log(p)); return; }

      statusEl.innerHTML = `<small>level.dat found (${levelEntry.name}) — reading...</small>`;
      const raw = await levelEntry.async('arraybuffer');
      let bytes = toUint8Array(raw);

      let nbtBytes = null;
      try{ nbtBytes = pako.ungzip(bytes); log('Ungzip successful — length', nbtBytes.length); }
      catch(e){ nbtBytes = bytes; log('Ungzip failed, using raw bytes'); }

      let parsed = null;
      try{
        parsed = await new Promise((resolve, reject)=>{
          const bufArg = (typeof Buffer !== 'undefined' && Buffer.from) ? Buffer.from(nbtBytes) : nbtBytes;
          nbtLib.parse(bufArg, (err, data)=>{ if(err) reject(err); else resolve(data); });
        });
      }catch(err){ statusEl.innerHTML = `<small style="color:crimson">NBT parse failed</small>`; log('NBT parse error:', err); return; }

      currentParsed = parsed; currentLevelPath = levelEntry.name;
      statusEl.innerHTML = `<small>NBT parsed — ready. Choose experiments and Build.</small>`;
      controls.style.display = 'block';

      try{
        const root = parsed.value || {};
        let expTag = null;
        if(root.Experiments && root.Experiments.value) expTag = root.Experiments.value;
        else if(root.Data && root.Data.value && root.Data.value.Experiments && root.Data.value.Experiments.value) expTag = root.Data.value.Experiments.value;
        else if(root.Data && root.Data.Experiments && root.Data.Experiments.value) expTag = root.Data.Experiments.value;

        if(expTag){
          const enabled = new Set(Object.keys(expTag).filter(k=>{
            const v = expTag[k];
            if(!v) return false;
            if(typeof v.value !== 'undefined') return v.value === 1 || v.value === true || v.value === '\x01';
            return false;
          }));
          document.querySelectorAll('.exp').forEach(cb=>{ cb.checked = enabled.has(cb.value); });
        }
      }catch(e){ log('Pre-check failed:', e); }

    }catch(e){ statusEl.innerHTML = `<small style="color:crimson">Failed to open archive: ${e.message}</small>`; log('Zip read error:', e); }
  }

  processBtn.addEventListener('click', async ()=>{
    if(!currentParsed || !currentZip) return alert('Load a .mcworld first');
    const chosen = Array.from(document.querySelectorAll('.exp:checked')).map(i=>i.value);
    log('Chosen experiments:', chosen);

    const root = currentParsed.value || {};
    if(!root.Data) root.Data = { type:'compound', value: {} };
    if(!root.Data.value) root.Data.value = root.Data.value || {};

    const expCompound = {};
    chosen.forEach(id => { expCompound[id] = { type: 'byte', value: 1 }; });

    root.Data.value.Experiments = { type: 'compound', value: expCompound };
    root.Experiments = { type: 'compound', value: expCompound };

    try{
      let writeBuf = null;
      if(nbtLib.writeUncompressed) writeBuf = nbtLib.writeUncompressed(currentParsed);
      else if(nbtLib.write) writeBuf = nbtLib.write(currentParsed);
      else throw new Error('No NBT write function found');

      let outBytes = toUint8Array(writeBuf);
      const gz = pako.gzip(outBytes);
      currentZip.file(currentLevelPath, gz, {binary:true});

      statusEl.innerHTML = `<small>Generating .mcworld...</small>`;
      const blob = await currentZip.generateAsync({type:'blob'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = currentFilename + '_experiments_enabled.mcworld';
      a.click();
      statusEl.innerHTML = `<small>Download started: ${a.download}</small>`;
      log('Download created');
    }catch(e){ statusEl.innerHTML = `<small style="color:crimson">Write/generate failed</small>`; log('Write error:', e); }
  });
})();
</script>
</body>
</html>
